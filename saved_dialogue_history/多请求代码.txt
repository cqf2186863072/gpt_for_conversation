system: 你是python高手
user: 你好
assistant: 你好！有什么Python问题我可以帮您解答吗？
user: 你会C#语言吗
assistant: 作为一个AI助手，我对C#语言也有一定了解。请问您有什么关于C#的问题，我可以尽量帮您解答。
user: 请帮我给代码添加一些功能，待会我会给你我的代码
assistant: 好的，请您提供您的C#代码，然后告诉我您想添加什么功能。我会尽力帮助您。
user: 我会提供python代码
assistant: 好的，请您提供您的Python代码，然后告诉我您想添加什么功能。我会尽力帮助您。
user: 多行、
assistant: 请提供您的Python代码，以便我了解您的需求并为您提供帮助。您可以将代码粘贴在这里。
user: import re
import os
import configparser
import json
import threading
import time
import sys
from datetime import datetime
from enum import Enum
from gpt_module import GPTClient

class InputMode(Enum):
    KEYBOARD = 0
    VOICE = 1

class OutputMode(Enum):
    PRINT = 0
    SPEAK = 1

class CheckResult(Enum):
    BREAK = 0
    CONTINUE = 1

class Message:
    def __init__(self, role, content):
        self.role = role
        self.content = content

    def to_dict(self):
        return {"role": f"{self.role}", "content": self.content}

class DialogueManager:
    def __init__(self, gpt_client, synthesizer=None, recognizer=None):
        self.gpt_client = gpt_client
        self.synthesizer = synthesizer
        self.recognizer = recognizer
        self.set_prompt()
        self.init_keywords()

    def init_keywords(self):
        self.InputMode = InputMode.KEYBOARD
        self.OutputMode = OutputMode.PRINT
        self.save_dialogue_words = ["保存", "save"]
        self.save_dialogue_pattern = self.build_pattern(self.save_dialogue_words)
        self.multiline_words = ["多行", "multiline"]
        self.multiline_pattern = self.build_pattern(self.multiline_words)
        self.switch_output_words = ["切换输出模式", "语音"]
        self.switch_output_pattern = self.build_pattern(self.switch_output_words)
        self.switch_input_words = ["切换输入模式", "切换", "switch", "change", "toggle"]
        self.switch_input_pattern = self.build_pattern(self.switch_input_words)
        self.exit_words = ["退出", "结束", "停止", "exit", "end", "quit"]
        self.exit_pattern = self.build_pattern(self.exit_words)

    def build_pattern(self, words):
        return "|".join([f"^({word})[。.]?\s*$" for word in words])

    def set_prompt(self, file_name=None):
        '''Method to set prompt and send dialogue history
        
        请在调用run方法前调用该方法

        '''
        if file_name:
            try:
                file_name = os.path.join('saved_dialogue_history', file_name)
                if os.path.exists(file_name):
                    # with open(file_name, 'r', encoding='utf-8') as file:
                    with open(file_name, 'r') as file:
                        self.dialogue_history = json.load(file)
                    print("prompt初始化成功")
                else:
                    raise Exception(f'未找到文件{file_name}')
            except Exception as e:
                print(e)
        else:
            self.dialogue_history = [{"role": "system", "content": ''}]

    def save_dialogue(self):
        file_name = input("请输入要保存的文件名：")
        if not file_name:
            file_name = datetime.now().strftime("%Y%m%d_%H%M%S")  # 默认命名为日期+时间

        # 创建'saved_dialogue_history'文件夹
        if not os.path.exists('saved_dialogue_history'):
            os.makedirs('saved_dialogue_history')

        # 将对话记录保存为json文件
        with open(os.path.join('saved_dialogue_history', file_name + '.json'), 'w') as file:
            json.dump(self.dialogue_history, file)

        # 将对话记录保存为txt文件
        with open(os.path.join('saved_dialogue_history', file_name + '.txt'), 'w', encoding='utf-8') as file:
            for message in self.dialogue_history:
                file.write(f"{message['role']}: {message['content']}\n")

        print("对话记录已保存")

    def get_multiline_input(self):
        print("请输入多行内容，以END结束")
        lines = []
        while True:
            line = input()
            if line == "END":
                break
            lines.append(line)
        return "\n".join(lines)

    def output(self, text):
        if self.synthesizer and self.OutputMode == OutputMode.SPEAK:
            self.synthesizer.text_to_speech_speaker_async(text)
        print(f"assistant: {text}")

    def switch_InputMode(self):
        if self.InputMode == InputMode.KEYBOARD:
            if self.recognizer:
                self.InputMode = InputMode.VOICE
                self.output("已切换到语音输入模式，请说话")
            else:
                print("抱歉，语音输入模式不可用，请使用键盘输入")
        else:
            self.InputMode = InputMode.KEYBOARD
            print("已切换到键盘输入模式，请输入")

    def switch_OutputMode(self):
        if self.OutputMode == OutputMode.PRINT:
            if self.synthesizer:
                self.OutputMode = OutputMode.SPEAK
                self.output("已切换到语音输出模式")
            else:
                print("抱歉，语音输出模式不可用")
        else:
            self.OutputMode = OutputMode.PRINT
            print("已切换到文本输出模式，请输入")

    def check_key_words(self):
        self.CheckResult = None

        if re.match(self.save_dialogue_pattern, self.user_input):
            self.save_dialogue()
            self.CheckResult = CheckResult.CONTINUE
        if re.match(self.switch_output_pattern, self.user_input):
            self.switch_OutputMode()
            self.CheckResult = CheckResult.CONTINUE
        if re.match(self.switch_input_pattern, self.user_input):
            self.switch_InputMode()
            self.CheckResult = CheckResult.CONTINUE
        if re.match(self.multiline_pattern, self.user_input):
            self.user_input = self.get_multiline_input()

        if re.match(self.exit_pattern, self.user_input):
            self.exit_flag = True
            self.CheckResult = CheckResult.BREAK

    def run(self):
        self.exit_flag = False
        self.loading_flag = False
        while not self.exit_flag:
            try:
                # 获取用户输入
                if self.InputMode == InputMode.VOICE:
                    print("User: ")
                    self.user_input = self.recognizer.speech_to_text_microphone()
                    print(self.user_input)
                else:
                    self.user_input = input("User: ")

                # 检查关键词
                self.check_key_words()
                if self.CheckResult == CheckResult.BREAK:
                    break
                elif self.CheckResult == CheckResult.CONTINUE:
                    continue

                # 将用户输入加入对话历史
                user_message = Message("user", self.user_input)
                self.dialogue_history.append(user_message.to_dict())
                
                # 设置一个线程，用于发送消息给gpt并接收回复
                def send_and_receive():
                    text = self.gpt_client.send_message(self.dialogue_history)
                    self.loading_flag = False
                    self.output(text)
                    assistant_message = Message("assistant", text)
                    self.dialogue_history.append(assistant_message.to_dict())
                    sys.exit()

                # 设置一个线程，用于显示加载情况
                def show_loading():
                    start_time = time.time()
                    while self.loading_flag:
                        print('加载中...      ', end='\r')
                        time.sleep(2)
                        if time.time() - start_time > 60:
                            print('长时间未响应，建议结束程序')
                            break
                    # print('已收到回复')
                    sys.exit()
                
                # 启动并等待线程结束
                self.loading_flag = True
                t1 = threading.Thread(target=send_and_receive)
                t1.start()
                t2 = threading.Thread(target=show_loading)
                t2.start()
                t1.join()
                t2.join()

            except Exception as e:
                print(f"Error: {e}")
                break
        print('感谢您使用本程序，再见！')


if __name__ == '__main__':
    # 用配置文件配置gpt
    config = configparser.ConfigParser()
    file_dir = os.path.dirname(__file__)
    config_file = os.path.join(file_dir, 'config.ini')
    try:
        if os.path.exists(config_file): 
            config.read(config_file)
            url = config.get('gpt', 'url')
            header = eval(config.get('gpt', 'header'))
        else:
            raise Exception("请配置config.ini")
    except Exception as e:
        print(e)
    gpt_client = GPTClient(url, header)

    # 手动配置gpt
    # url = "https://gpt-4-32k-api.com/" # replace with your own url
    # header = {"Authorization": "Bearer xxx"} # replace with your own header
    # gpt_client = GPTClient(url, header)

    # 运行对话系统
    dialogue_manager = DialogueManager(gpt_client)
    dialogue_manager.set_prompt('编程高手.json')
    dialogue_manager.run()
我需要一个新功能，即向gpt发送多个请求，返回的回复依次打印或保存到文件中
assistant: 为了实现这个功能，我们可以在`DialogueManager`类中添加一个新方法`send_multiple_requests`，并在`run`方法中调用它。这是修改后的代码：

```python
class DialogueManager:
    # ... 其他代码保持不变 ...

    def send_multiple_requests(self, requests):
        responses = []
        for request in requests:
            self.user_input = request
            user_message = Message("user", self.user_input)
            self.dialogue_history.append(user_message.to_dict())

            text = self.gpt_client.send_message(self.dialogue_history)
            responses.append(text)

            assistant_message = Message("assistant", text)
            self.dialogue_history.append(assistant_message.to_dict())

        return responses

    def run(self):
        # ... 其他代码保持不变 ...

        # 在此处添加要发送的多个请求
        multiple_requests = ["请求1", "请求2", "请求3"]

        # 向GPT发送多个请求并获取回复
        responses = self.send_multiple_requests(multiple_requests)

        # 打印回复
        for response in responses:
            print(response)

        # 将回复保存到文件
        with open('multiple_responses.txt', 'w', encoding='utf-8') as file:
            for response in responses:
                file.write(response + "\n")

        # ... 其他代码保持不变 ...
```

在这个例子中，我添加了一个`send_multiple_requests`方法，它接受一个字符串列表（即要发送的多个请求），并返回一个包含所有回复的列表。在`run`方法中，我添加了一个`multiple_requests`列表，用于存储要发送的多个请求。然后，我调用`send_multiple_requests`方法获取回复，并将回复打印到控制台以及保存到一个名为`multiple_responses.txt`的文件中。

请注意，这个例子仅用于演示如何发送多个请求并获取回复。您可能需要根据您的实际需求对代码进行进一步调整。
user: 你记得我的代码里实现了什么功能吗
assistant: 当然，您的代码实现了一个基于GPT的对话系统。以下是代码的主要功能：

1. 定义了一些枚举类，如`InputMode`、`OutputMode`、`CheckResult`，用于表示输入模式、输出模式和检查结果。

2. 定义了一个`Message`类，用于表示对话中的消息。

3. 定义了一个`DialogueManager`类，负责管理与GPT的对话。`DialogueManager`类的主要功能如下：

   - 初始化GPT客户端、语音合成器和语音识别器（如果有的话）。
   - 定义了一些关键词和正则表达式，用于识别用户输入的命令。
   - 提供了设置对话历史的方法`set_prompt`。
   - 提供了保存对话历史到文件的方法`save_dialogue`。
   - 提供了获取多行输入的方法`get_multiline_input`。
   - 提供了输出文本或语音的方法`output`。
   - 提供了切换输入模式和输出模式的方法`switch_InputMode`和`switch_OutputMode`。
   - 提供了检查用户输入关键词的方法`check_key_words`。
   - 提供了运行对话系统的方法`run`，负责与用户交互并将用户输入发送给GPT，然后显示GPT的回复。

4. 在`__main__`部分，您的代码首先从配置文件中读取GPT的URL和header，然后创建一个`GPTClient`实例。接着，创建一个`DialogueManager`实例，并调用`set_prompt`方法设置对话历史。最后，调用`run`方法运行对话系统。
user: 请你记住以下代码，这是我修改后的代码
```
import re
import os
import configparser
import json
import threading
import time
import sys
from datetime import datetime
from enum import Enum
from gpt_module import GPTClient

class InputMode(Enum):
    KEYBOARD = 0
    VOICE = 1

class OutputMode(Enum):
    PRINT = 0
    SPEAK = 1

class CheckResult(Enum):
    BREAK = 0
    CONTINUE = 1

class Message:
    def __init__(self, role, content):
        self.role = role
        self.content = content

    def to_dict(self):
        return {"role": f"{self.role}", "content": self.content}

class DialogueManager:
    def __init__(self, gpt_client, synthesizer=None, recognizer=None):
        self.gpt_client = gpt_client
        self.synthesizer = synthesizer
        self.recognizer = recognizer
        self.set_prompt()
        self.init_keywords()

    def init_keywords(self):
        self.InputMode = InputMode.KEYBOARD
        self.OutputMode = OutputMode.PRINT
        self.save_dialogue_words = ["保存", "save"]
        self.save_dialogue_pattern = self.build_pattern(self.save_dialogue_words)
        self.multiline_words = ["多行", "multiline"]
        self.multiline_pattern = self.build_pattern(self.multiline_words)
        self.switch_output_words = ["切换输出模式", "语音"]
        self.switch_output_pattern = self.build_pattern(self.switch_output_words)
        self.switch_input_words = ["切换输入模式", "切换", "switch", "change", "toggle"]
        self.switch_input_pattern = self.build_pattern(self.switch_input_words)
        self.exit_words = ["退出", "结束", "停止", "exit", "end", "quit"]
        self.exit_pattern = self.build_pattern(self.exit_words)

    def build_pattern(self, words):
        return "|".join([f"^({word})[。.]?\s*$" for word in words])

    def set_prompt(self, file_name=None):
        '''Method to set prompt and send dialogue history
        
        请在调用run方法前调用该方法

        '''
        if file_name:
            try:
                file_name = os.path.join('saved_dialogue_history', file_name)
                if os.path.exists(file_name):
                    # with open(file_name, 'r', encoding='utf-8') as file:
                    with open(file_name, 'r') as file:
                        self.dialogue_history = json.load(file)
                    print("prompt初始化成功")
                else:
                    raise Exception(f'未找到文件{file_name}')
            except Exception as e:
                print(e)
        else:
            self.dialogue_history = [{"role": "system", "content": ''}]

    def save_dialogue(self):
        file_name = input("请输入要保存的文件名：")
        if not file_name:
            file_name = datetime.now().strftime("%Y%m%d_%H%M%S")  # 默认命名为日期+时间

        # 创建'saved_dialogue_history'文件夹
        if not os.path.exists('saved_dialogue_history'):
            os.makedirs('saved_dialogue_history')

        # 将对话记录保存为json文件
        with open(os.path.join('saved_dialogue_history', file_name + '.json'), 'w') as file:
            json.dump(self.dialogue_history, file)

        # 将对话记录保存为txt文件
        with open(os.path.join('saved_dialogue_history', file_name + '.txt'), 'w', encoding='utf-8') as file:
            for message in self.dialogue_history:
                file.write(f"{message['role']}: {message['content']}\n")

        print("对话记录已保存")

    def get_multiline_input(self):
        print("请输入多行内容，以END结束")
        lines = []
        while True:
            line = input()
            if line == "END":
                break
            lines.append(line)
        return "\n".join(lines)

    def output(self, text):
        if self.synthesizer and self.OutputMode == OutputMode.SPEAK:
            self.synthesizer.text_to_speech_speaker_async(text)
        print(f"assistant: {text}")

    def switch_InputMode(self):
        if self.InputMode == InputMode.KEYBOARD:
            if self.recognizer:
                self.InputMode = InputMode.VOICE
                self.output("已切换到语音输入模式，请说话")
            else:
                print("抱歉，语音输入模式不可用，请使用键盘输入")
        else:
            self.InputMode = InputMode.KEYBOARD
            print("已切换到键盘输入模式，请输入")

    def switch_OutputMode(self):
        if self.OutputMode == OutputMode.PRINT:
            if self.synthesizer:
                self.OutputMode = OutputMode.SPEAK
                self.output("已切换到语音输出模式")
            else:
                print("抱歉，语音输出模式不可用")
        else:
            self.OutputMode = OutputMode.PRINT
            print("已切换到文本输出模式，请输入")

    def check_key_words(self):
        self.CheckResult = None

        if re.match(self.save_dialogue_pattern, self.user_input):
            self.save_dialogue()
            self.CheckResult = CheckResult.CONTINUE
        if re.match(self.switch_output_pattern, self.user_input):
            self.switch_OutputMode()
            self.CheckResult = CheckResult.CONTINUE
        if re.match(self.switch_input_pattern, self.user_input):
            self.switch_InputMode()
            self.CheckResult = CheckResult.CONTINUE
        if re.match(self.multiline_pattern, self.user_input):
            self.user_input = self.get_multiline_input()

        if re.match(self.exit_pattern, self.user_input):
            self.exit_flag = True
            self.CheckResult = CheckResult.BREAK

    def run(self):
        self.exit_flag = False
        self.loading_flag = False
        while not self.exit_flag:
            try:
                # 获取用户输入
                if self.InputMode == InputMode.VOICE:
                    print("User: ")
                    self.user_input = self.recognizer.speech_to_text_microphone()
                    print(self.user_input)
                else:
                    self.user_input = input("User: ")

                # 检查关键词
                self.check_key_words()
                if self.CheckResult == CheckResult.BREAK:
                    break
                elif self.CheckResult == CheckResult.CONTINUE:
                    continue

                # 将用户输入加入对话历史
                user_message = Message("user", self.user_input)
                self.dialogue_history.append(user_message.to_dict())
                
                # 设置一个线程，用于发送消息给gpt并接收回复
                def send_and_receive():
                    text = self.gpt_client.send_request(self.dialogue_history)
                    self.loading_flag = False
                    self.output(text)
                    assistant_message = Message("assistant", text)
                    self.dialogue_history.append(assistant_message.to_dict())
                    sys.exit()

                # 设置一个线程，用于显示加载情况
                def show_loading():
                    start_time = time.time()
                    while self.loading_flag:
                        print('加载中...      ', end='\r')
                        time.sleep(2)
                        if time.time() - start_time > 60:
                            print('长时间未响应，建议结束程序')
                            break
                    # print('已收到回复')
                    sys.exit()
                
                # 启动并等待线程结束
                self.loading_flag = True
                t1 = threading.Thread(target=send_and_receive)
                t1.start()
                t2 = threading.Thread(target=show_loading)
                t2.start()
                t1.join()
                t2.join()

            except Exception as e:
                print(f"Error: {e}")
                break
        print('感谢您使用本程序，再见！')


if __name__ == '__main__':
    # 用配置文件配置gpt
    config = configparser.ConfigParser()
    file_dir = os.path.dirname(__file__)
    config_file = os.path.join(file_dir, 'config.ini')
    try:
        if os.path.exists(config_file): 
            config.read(config_file)
            url = config.get('gpt', 'url')
            header = eval(config.get('gpt', 'header'))
        else:
            raise Exception("请配置config.ini")
    except Exception as e:
        print(e)
    gpt_client = GPTClient(url, header)

    # 手动配置gpt
    # url = "https://gpt-4-32k-api.com/" # replace with your own url
    # header = {"Authorization": "Bearer xxx"} # replace with your own header
    # gpt_client = GPTClient(url, header)

    # 运行对话系统
    dialogue_manager = DialogueManager(gpt_client)
    dialogue_manager.set_prompt('多请求代码.json')
    dialogue_manager.run()
```
assistant: 我已经记住了您修改后的代码。如果您有任何关于这段代码的问题或需要帮助，请随时告诉我。
user: 下面是gpt_module.py里的代码，也请你记住
```
import requests

class GPTClient:
    def __init__(self, url, header):
        self.url = url
        self.header = header

    def send_request(self, message, temperature = 0.5):
        '''sends requests to openai

        Args:
            message: A dictionary list inclueding dialogue histohry and new input
            temperature: Randomness of responses

        '''
        data = {
            'model_name': 'gpt-4-32k',
            'message': message,
            'temperature': temperature
        }

        try:
            response = requests.post(url=self.url, headers=self.header, json=data)
            if response.status_code == 200:
                return response.json()['result']
            else:
                raise Exception(f"Request failed with status code {response.status_code}")
        except requests.exceptions.RequestException as e:
            raise Exception(f"Request exception: {e}")
```        
assistant: 我已经记住了您提供的`gpt_module.py`代码。这个模块定义了一个`GPTClient`类，它负责与GPT服务器通信。类中的`send_request`方法接受一个消息列表（包含对话历史和新输入）和一个温度参数，然后向GPT服务器发送请求，最后返回服务器的响应。如果您有关于这段代码的任何问题或需要帮助，请随时告诉我。
