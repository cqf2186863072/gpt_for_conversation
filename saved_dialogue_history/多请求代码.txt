system: 你是python高手
user: 你好
assistant: 你好！有什么Python问题我可以帮您解答吗？
user: 你会C#语言吗
assistant: 作为一个AI助手，我对C#语言也有一定了解。请问您有什么关于C#的问题，我可以尽量帮您解答。
user: 请帮我给代码添加一些功能，待会我会给你我的代码
assistant: 好的，请您提供您的C#代码，然后告诉我您想添加什么功能。我会尽力帮助您。
user: 我会提供python代码
assistant: 好的，请您提供您的Python代码，然后告诉我您想添加什么功能。我会尽力帮助您。
user: 多行、
assistant: 请提供您的Python代码，以便我了解您的需求并为您提供帮助。您可以将代码粘贴在这里。
user: import re
import os
import configparser
import json
import threading
import time
import sys
from datetime import datetime
from enum import Enum
from gpt_module import GPTClient

class InputMode(Enum):
    KEYBOARD = 0
    VOICE = 1

class OutputMode(Enum):
    PRINT = 0
    SPEAK = 1

class CheckResult(Enum):
    BREAK = 0
    CONTINUE = 1

class Message:
    def __init__(self, role, content):
        self.role = role
        self.content = content

    def to_dict(self):
        return {"role": f"{self.role}", "content": self.content}

class DialogueManager:
    def __init__(self, gpt_client, synthesizer=None, recognizer=None):
        self.gpt_client = gpt_client
        self.synthesizer = synthesizer
        self.recognizer = recognizer
        self.set_prompt()
        self.init_keywords()

    def init_keywords(self):
        self.InputMode = InputMode.KEYBOARD
        self.OutputMode = OutputMode.PRINT
        self.save_dialogue_words = ["保存", "save"]
        self.save_dialogue_pattern = self.build_pattern(self.save_dialogue_words)
        self.multiline_words = ["多行", "multiline"]
        self.multiline_pattern = self.build_pattern(self.multiline_words)
        self.switch_output_words = ["切换输出模式", "语音"]
        self.switch_output_pattern = self.build_pattern(self.switch_output_words)
        self.switch_input_words = ["切换输入模式", "切换", "switch", "change", "toggle"]
        self.switch_input_pattern = self.build_pattern(self.switch_input_words)
        self.exit_words = ["退出", "结束", "停止", "exit", "end", "quit"]
        self.exit_pattern = self.build_pattern(self.exit_words)

    def build_pattern(self, words):
        return "|".join([f"^({word})[。.]?\s*$" for word in words])

    def set_prompt(self, file_name=None):
        '''Method to set prompt and send dialogue history
        
        请在调用run方法前调用该方法

        '''
        if file_name:
            try:
                file_name = os.path.join('saved_dialogue_history', file_name)
                if os.path.exists(file_name):
                    # with open(file_name, 'r', encoding='utf-8') as file:
                    with open(file_name, 'r') as file:
                        self.dialogue_history = json.load(file)
                    print("prompt初始化成功")
                else:
                    raise Exception(f'未找到文件{file_name}')
            except Exception as e:
                print(e)
        else:
            self.dialogue_history = [{"role": "system", "content": ''}]

    def save_dialogue(self):
        file_name = input("请输入要保存的文件名：")
        if not file_name:
            file_name = datetime.now().strftime("%Y%m%d_%H%M%S")  # 默认命名为日期+时间

        # 创建'saved_dialogue_history'文件夹
        if not os.path.exists('saved_dialogue_history'):
            os.makedirs('saved_dialogue_history')

        # 将对话记录保存为json文件
        with open(os.path.join('saved_dialogue_history', file_name + '.json'), 'w') as file:
            json.dump(self.dialogue_history, file)

        # 将对话记录保存为txt文件
        with open(os.path.join('saved_dialogue_history', file_name + '.txt'), 'w', encoding='utf-8') as file:
            for message in self.dialogue_history:
                file.write(f"{message['role']}: {message['content']}\n")

        print("对话记录已保存")

    def get_multiline_input(self):
        print("请输入多行内容，以END结束")
        lines = []
        while True:
            line = input()
            if line == "END":
                break
            lines.append(line)
        return "\n".join(lines)

    def output(self, text):
        if self.synthesizer and self.OutputMode == OutputMode.SPEAK:
            self.synthesizer.text_to_speech_speaker_async(text)
        print(f"assistant: {text}")

    def switch_InputMode(self):
        if self.InputMode == InputMode.KEYBOARD:
            if self.recognizer:
                self.InputMode = InputMode.VOICE
                self.output("已切换到语音输入模式，请说话")
            else:
                print("抱歉，语音输入模式不可用，请使用键盘输入")
        else:
            self.InputMode = InputMode.KEYBOARD
            print("已切换到键盘输入模式，请输入")

    def switch_OutputMode(self):
        if self.OutputMode == OutputMode.PRINT:
            if self.synthesizer:
                self.OutputMode = OutputMode.SPEAK
                self.output("已切换到语音输出模式")
            else:
                print("抱歉，语音输出模式不可用")
        else:
            self.OutputMode = OutputMode.PRINT
            print("已切换到文本输出模式，请输入")

    def check_key_words(self):
        self.CheckResult = None

        if re.match(self.save_dialogue_pattern, self.user_input):
            self.save_dialogue()
            self.CheckResult = CheckResult.CONTINUE
        if re.match(self.switch_output_pattern, self.user_input):
            self.switch_OutputMode()
            self.CheckResult = CheckResult.CONTINUE
        if re.match(self.switch_input_pattern, self.user_input):
            self.switch_InputMode()
            self.CheckResult = CheckResult.CONTINUE
        if re.match(self.multiline_pattern, self.user_input):
            self.user_input = self.get_multiline_input()

        if re.match(self.exit_pattern, self.user_input):
            self.exit_flag = True
            self.CheckResult = CheckResult.BREAK

    def run(self):
        self.exit_flag = False
        self.loading_flag = False
        while not self.exit_flag:
            try:
                # 获取用户输入
                if self.InputMode == InputMode.VOICE:
                    print("User: ")
                    self.user_input = self.recognizer.speech_to_text_microphone()
                    print(self.user_input)
                else:
                    self.user_input = input("User: ")

                # 检查关键词
                self.check_key_words()
                if self.CheckResult == CheckResult.BREAK:
                    break
                elif self.CheckResult == CheckResult.CONTINUE:
                    continue

                # 将用户输入加入对话历史
                user_message = Message("user", self.user_input)
                self.dialogue_history.append(user_message.to_dict())
                
                # 设置一个线程，用于发送消息给gpt并接收回复
                def send_and_receive():
                    text = self.gpt_client.send_message(self.dialogue_history)
                    self.loading_flag = False
                    self.output(text)
                    assistant_message = Message("assistant", text)
                    self.dialogue_history.append(assistant_message.to_dict())
                    sys.exit()

                # 设置一个线程，用于显示加载情况
                def show_loading():
                    start_time = time.time()
                    while self.loading_flag:
                        print('加载中...      ', end='\r')
                        time.sleep(2)
                        if time.time() - start_time > 60:
                            print('长时间未响应，建议结束程序')
                            break
                    # print('已收到回复')
                    sys.exit()
                
                # 启动并等待线程结束
                self.loading_flag = True
                t1 = threading.Thread(target=send_and_receive)
                t1.start()
                t2 = threading.Thread(target=show_loading)
                t2.start()
                t1.join()
                t2.join()

            except Exception as e:
                print(f"Error: {e}")
                break
        print('感谢您使用本程序，再见！')


if __name__ == '__main__':
    # 用配置文件配置gpt
    config = configparser.ConfigParser()
    file_dir = os.path.dirname(__file__)
    config_file = os.path.join(file_dir, 'config.ini')
    try:
        if os.path.exists(config_file): 
            config.read(config_file)
            url = config.get('gpt', 'url')
            header = eval(config.get('gpt', 'header'))
        else:
            raise Exception("请配置config.ini")
    except Exception as e:
        print(e)
    gpt_client = GPTClient(url, header)

    # 手动配置gpt
    # url = "https://gpt-4-32k-api.com/" # replace with your own url
    # header = {"Authorization": "Bearer xxx"} # replace with your own header
    # gpt_client = GPTClient(url, header)

    # 运行对话系统
    dialogue_manager = DialogueManager(gpt_client)
    dialogue_manager.set_prompt('编程高手.json')
    dialogue_manager.run()
我需要一个新功能，即向gpt发送多个请求，返回的回复依次打印或保存到文件中
assistant: 为了实现这个功能，我们可以在`DialogueManager`类中添加一个新方法`send_multiple_requests`，并在`run`方法中调用它。这是修改后的代码：

```python
class DialogueManager:
    # ... 其他代码保持不变 ...

    def send_multiple_requests(self, requests):
        responses = []
        for request in requests:
            self.user_input = request
            user_message = Message("user", self.user_input)
            self.dialogue_history.append(user_message.to_dict())

            text = self.gpt_client.send_message(self.dialogue_history)
            responses.append(text)

            assistant_message = Message("assistant", text)
            self.dialogue_history.append(assistant_message.to_dict())

        return responses

    def run(self):
        # ... 其他代码保持不变 ...

        # 在此处添加要发送的多个请求
        multiple_requests = ["请求1", "请求2", "请求3"]

        # 向GPT发送多个请求并获取回复
        responses = self.send_multiple_requests(multiple_requests)

        # 打印回复
        for response in responses:
            print(response)

        # 将回复保存到文件
        with open('multiple_responses.txt', 'w', encoding='utf-8') as file:
            for response in responses:
                file.write(response + "\n")

        # ... 其他代码保持不变 ...
```

在这个例子中，我添加了一个`send_multiple_requests`方法，它接受一个字符串列表（即要发送的多个请求），并返回一个包含所有回复的列表。在`run`方法中，我添加了一个`multiple_requests`列表，用于存储要发送的多个请求。然后，我调用`send_multiple_requests`方法获取回复，并将回复打印到控制台以及保存到一个名为`multiple_responses.txt`的文件中。

请注意，这个例子仅用于演示如何发送多个请求并获取回复。您可能需要根据您的实际需求对代码进行进一步调整。
